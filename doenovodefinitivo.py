# -*- coding: utf-8 -*-
"""DOENOVODEFINITIVO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rxKVNIYpgH5dYxU2IwRRSNJOV0IY8h6u
"""

#instalações somente necessarias para o google colab
!apt update
!apt install chromium-chromedriver
!pip install selenium
!pip install pdfminer

#importações, pdf miner, selenium, email
import email, smtplib, ssl
import os
import glob
import time
import re
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.layout import LAParams
from pdfminer.converter import TextConverter
from io import StringIO
from pdfminer.pdfpage import PDFPage
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys

#DEF do leitor de PDF e retorna uma string com todo o texto do PDF
def get_pdf_file_content(path_to_pdf):
  resource_manager = PDFResourceManager(caching=True)
  out_text = StringIO()
  #codec = 'utf-8'
  laParams = LAParams()
  text_converter = TextConverter(resource_manager, out_text, laparams=laParams)
  fp = open(path_to_pdf, 'rb')
  interpreter = PDFPageInterpreter(resource_manager, text_converter)
  for page in PDFPage.get_pages(fp, pagenos=set(), maxpages=0, password="", caching=True, check_extractable=True):
    interpreter.process_page(page)
  text = out_text.getvalue()
  fp.close()
  text_converter.close()
  out_text.close()
  return text.upper()

#Definição que procura a palavra chave, em um texto (retorno da função anterior)
#Deve ser alimentada na função, a variavel que armazena a string do PDF, e uma lista contendo as palavras chaves
def procurar_palavras(texto, lista):
  for each in lista:
    indices_object = re.finditer(pattern=each, string=texto)
    indices = [index.start() for index in indices_object]
    for i,item in enumerate(indices):
      pos_final = texto.find('COD. MAT.', indices[i] +1)
      texto_print = texto[indices[i]:pos_final]
      extrato = open('extrato.txt', "a", encoding='utf-8')
      extrato.write("<br>")
      extrato.write(texto_print)
      extrato.write('<br>')
  extrato.close()

#Função que envia o email, deve ser alimentada com email do emissor, receptor, assunto da mensagem, senha a mensagem é o arquivo gerado pela função anterior
#armazenado pela função OPEN numa variavel
def enviar_email(emissor, receptor, assunto, senha, mensagem):

  # Create a multipart message and set headers
  message = MIMEMultipart()
  message["From"] = emissor
  message["To"] = receptor
  message["Subject"] = assunto
  message["Bcc"] = receptor  # Recommended for mass emails

  # Add body to email
  message.attach(MIMEText(mensagem, "html"))

  #filename = ""  # In same directory as script

  # Open PDF file in binary mode
  #with open(filename, "rb") as attachment:
      # Add file as application/octet-stream
      # Email client can usually download this automatically as attachment
  #part = MIMEBase("application", "octet-stream")
  #part.set_payload(attachment.read())

  # Encode file in ASCII characters to send by email    
  #encoders.encode_base64(part)

  # Add header as key/value pair to attachment part
  #part.add_header(
  #    "Content-Disposition",
  #    f"attachment; filename= {filename}",
  #)

  # Add attachment to message and convert message to string
  #message.attach(part)
  text = message.as_string()

  # Log in to server using secure context and send email
  context = ssl.create_default_context()
  with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
      server.login(emissor, senha)
      server.sendmail(emissor, receptor, text)

try:
    os.remove("texto2.txt")
except:
    pass
try:
    os.remove("extrato2.txt")
except:
    pass
try:
    os.remove("doe.pdf")
except:
    pass
try:
    os.remove("texto.txt")
except:
    pass
try:
    os.remove("extrato.txt")
except:
    pass
try:
    os.remove("doe2.pdf")
except:
    pass

#Obtenção do dois ultimos DOES atraves do selenium, por simples click no XPATH para download
options = webdriver.ChromeOptions()
options.add_argument('--headless')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
options.add_argument("--window-size=1920,1080")
wd = webdriver.Chrome(options=options)
wd.get("https://doe.sea.sc.gov.br/") # informar a pagina de destino
#click em cada elemento para download
wd.find_element(by=By.XPATH, value="/html/body/div[1]/div/div/section[3]/div/div/div[2]/div/div/div[1]/div/div/div[1]/div/div/div[2]/a").click()
wd.find_element(by=By.XPATH, value="/html/body/div[1]/div/div/section[3]/div/div/div[2]/div/div/div[1]/div/div/div[2]/div/div/div[2]/a").click()
#armazenando os dos arquivos em uma lista
time.sleep(20)
arquivos = []
arquivos = glob.glob("*.pdf")

#definindo as palavras chaves a serem procuradas
search_keywords=['',
                 ]
#definindo parametros de email
sender_email = ""
receiver_email = ""
password = ""

#chamando as funlções para cada arquivo
for each in arquivos:
  subject = (f'Verificação DOE: {each}')
  path_to_pdf = each
  texto = get_pdf_file_content(path_to_pdf)
  procurar_palavras(texto, search_keywords)
  body = open("extrato.txt", "r", encoding="utf-8").read()
  enviar_email(sender_email, receiver_email, subject, password, body)
  os.remove(each)
  os.remove('extrato.txt')
